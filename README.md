#IO-bound. Проверяем ссылки на страницах Википедии

Время работы синхронной проверки ссылок:

![](screenshots%20multithreading%20test/Thred%201.png)


Загрузка памяти, процессора, сети:

![](screenshots%20multithreading%20test/ThreadPoolExecutor-1.png)


Время работы проверки ссылок при 5 воркеров:

![](screenshots%20multithreading%20test/Thread%205.png)


Время работы проверки ссылок при 10 воркеров:

![](screenshots%20multithreading%20test/Thread%2010.png)


Время работы проверки ссылок при 100 воркеров:

![](screenshots%20multithreading%20test/Thread%20100.png)

Загрузка памяти, процессора, сети:

![](screenshots%20multithreading%20test/ThreadPoolExecutor-100.png)

Вывод: 

С увеличением количества воркеров, увеличилось нагрузка ЦП и Сети. Время
выполнения программы уменьшилось по сравнению с одним потоком, но в сравнении с 5,
10 и 100 воркерами время не так сильно меняется. Если взять в учет то, что 
во время нашего тестирования на ноутбуке параллельно работают ещё много
программ, то результаты не такие объективные, и от случая к случаю
время при 5, 10 и 100 воркерах меняется, и не всегда чем больше воркеров, 
тем выше производительность.

#CPU-bound. Генерируем монетки
Для тестирования я генирировал 5 монет.


Время генерации на 1 ядре:

![](screenshots%20processes%20test/Process%201.png)

Загрузка памяти, процессора, сети при 1 воркере:

![](screenshots%20processes%20test/ProcessPoolExecutor-1.png)


Время генерации при 2 воркерах:

![](screenshots%20processes%20test/Process%202.png)

Время генерации при 4 воркерах:

![](screenshots%20processes%20test/Process%204.png)

Загрузка памяти, процессора, сети при 4:

![](screenshots%20processes%20test/ProcessPoolExecutor-4.png)


Время генерации при 5 воркерах:

![](screenshots%20processes%20test/Process%205.png)

Загрузка памяти, процессора, сети при 5:

![](screenshots%20processes%20test/ProcessPoolExecutor-5.png)


Время генерации при 10 воркерах:

![](screenshots%20processes%20test/Process%2010.png)

Загрузка памяти, процессора, сети при 10:

![](screenshots%20processes%20test/ProcessPoolExecutor-10.png)


Результат при 100 воркерах:

![](screenshots%20processes%20test/Process%20100.png)


Вывод:

С увеличением количесива врокеров, время выполнения программы становится
меньше, но до орпеделенного количества. Когда число воркеров приближается
к числу ядер, прирост производительности становится все меньше. А когда мы превышаем число ядер, время выполнения перестает уменьшаться. При
числе воркеров больше 61, библиотека выдает ошибку, из-за ограничения 
Windows.

С ростом числа воркеров, увеличивается нагрузка на процессор.

Так как на моем наутбуке параллельно запущено много процессов, то картина не всегда
получается объективной. Так, например, при числе воркеров равным 10, время выполнения стало больше по
сравнению с 5. Я запускал несоклко раз профайллер на 5 и 4 воркерах,
и время иногда получалось такое же.

Таким образом, мы можем прийти к выводу, что необходимо учитывать параметры
системы, на которой будет выполняться программа, при продумывании многопоточности
и запуске нескольких процесов в проекте.
